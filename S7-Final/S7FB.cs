/*
ID 
отчёт 
задача https://contest.yandex.ru/contest/25597/problems/B/

-- ПРИНЦИП РАБОТЫ --
По условиям задачи на вход подаётся массив неотрицательных чисел values и число n, нужно найти его подмассив,
такой, что его сумма равна n.
Решение идёт через двумерную динамику.
Множество решений хранится в двумерном массиве (n x totalSum/2). При этом:
- по горизонтали при i = 0...n перебираются подмножества массива, где [0, 0] - пустое подмножество
- по вертикали при j = 0...n перебираются промежуточные значения суммы 0...totalSum/2
В ячейках bool[,] dp хранятся значения, такие, что:
dp[j, i] == true, если существует подмножество подмножества исходного массива (с элементами 1..i)
(т.е., подмножество массива values.Take(i)) с общей суммой == j, иначе false.
Базовый случай динамики:
Инициализируем первую строку (j == 0), заполняем true. 
Переход динамики:
Проходим по всем элементам dp[j, i]. Здесь два варианта.
Первый вариант: для меньшего подмножества dp[j, i - 1] ранее уже было найдено, что 
оно содержит подмножество с такой суммой, значит, это справедливо и для этого (большего) подмножества.
Иначе смотрим на подмножество без последнего i-го элемента и проверяем,
наберём ли мы там элементов на сумму (j - arr[i - 1]) (она должна быть не отрицательна)
но эта задача уже решалась, её результат в ячейке dp[j - arr[i - 1], i - 1]
в ряду с j'= j - arr[i - 1], найден для подмножества без последнего i-го элемента
-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Базовый случай динамики:
Инициализируем первую строку (j == 0), заполняем true. Можем это сделать, 
т.к. подмножество подмножества может иметь сумму 0 всегда, поскольку для пустого множества сумма 0.
Переход динамики. Задача разделима на подзадачи, поскольку
во-первых (проход по i), если подмножество данного множества имеет подмножество нужной суммы, 
то и текущее множество имеет такое подмножество.
во-вторых (проход по j), если для подмножества найдены элементы общей суммы aSum, то при включении
элемента values[i - 1] итоговое подмножество будет иметь элементы общей суммы aSum + values[i - 1].
-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность O(n × totalSum/2), т.к. считаем ячейки матрицы n × totalSum/2, которая
содержит промежуточные решения.
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственная сложность O(n × totalSum/2), из-за хранения двумерного массива dp
промежуточных решений.
*/

using System;
using System.IO;
using System.Linq;

namespace S7FB
{
    class Solution
    {
        public static TextReader reader;
        public static TextWriter writer;

        public static void Main(string[] args)
        {
            reader = new StreamReader(Console.OpenStandardInput());
            writer = new StreamWriter(Console.OpenStandardOutput());

            int n = ReadInt();
            int[] values = ReadInts();

            bool partitionable = isPartitionable(values, n);
            writer.WriteLine(partitionable);

            writer.Close();
            reader.Close();
        }

        private static int ReadInt()
        {
            return int.Parse(Console.ReadLine());
        }

        private static int[] ReadInts()
        {
            return Console.ReadLine()
                .Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries)
                .Select(int.Parse)
                .ToArray();
        }

        /// <summary>
        /// Решение через двумерную динамику
        /// По горизонтали при i = 0...n перебираются подмножества массива, где [0, 0] - пустое подмножество
        /// По вертикали при j = 0...n перебираются промежуточные значения суммы 0...totalSum/2
        /// </summary>
        private static bool isPartitionable(int[] values, int n)
        {
            int totalSum = values.Sum();
            int halfSum = totalSum / 2;
            if (totalSum % 2 != 0)
                return false;

            // dp[j, i] == true, если существует подмножество подмножества (с элементами 1..i)
            // исходного массива с общей суммой == j, иначе false
            bool[,] dp = new bool[halfSum + 1, n + 1];

            // базовый случай динамики
            // Инициализируем первую строку (j == 0)
            // Можем это сделать, т.к. подмножество подмножества может иметь сумму 0 всегда,
            // поскольку для пустого подмножества сумма 0
            for (int i = 0; i < n; i++)
                dp[0, i] = true;

            // переход динамики
            for (int j = 1; j <= halfSum; j++)
            {
                for (int i = 1; i <= n; i++)
                {
                    // Первый вариант: для меньшего подмножества dp[j, i - 1] ранее уже было найдено, что 
                    // оно содержит подмножество с такой суммой, значит, и это подмножество, большее
                    // на i-й элемент содержит подмножество с общей суммой j
                    if (dp[j, i - 1] == true)
                        dp[j, i] = true;
                    else
                    {
                        // Допустим, это не так, и из подмножества без последнего i-го элемента
                        // нельзя набрать элементов с суммой j
                        // Тогда смотрим на подмножество без последнего i-го элемента и проверяем,
                        // наберём ли мы там элементов на сумму (j - arr[i - 1], она должна быть не отрицательна)
                        // но эта задача уже решалась, её результат в ячейке dp[j - arr[i - 1], i - 1]
                        // в ряду с j'= j - arr[i - 1], найден для подмножества без последнего i-го элемента
                        int sumWOIElement = j - values[i - 1];
                        if (sumWOIElement >= 0)
                            dp[j, i] = dp[sumWOIElement, i - 1];
                        else
                            dp[j, i] = false;
                    }
                }
            }

            // в правом нижнем углу будет ответ: содержит ли подмножество из элементов 1..n 
            // (т.е., весь исходный массив) такие элементы, которые вместе имеют суму == totalSum/2
            return dp[halfSum, n];
        }
    }
}